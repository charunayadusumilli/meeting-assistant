"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const electron = require("electron");
const electronUpdater = require("electron-updater");
const fs = require("fs");
const path = require("path");
const alwaysResolve_1 = require("../alwaysResolve");
const getConfig_1 = require("../getConfig");
const setTimeout_1 = require("../setTimeout");
const getReleaseStatus_1 = require("./getReleaseStatus");
const updaterAgents_1 = require("./updaterAgents");
const version_1 = require("../version");
const types_1 = require("../types");
const BaseAutoUpdater_1 = require("./BaseAutoUpdater");
class AutoUpdater extends BaseAutoUpdater_1.BaseAutoUpdater {
    constructor({ autoCheckInterval = 10 * 60 * 1000, // 10 min
    logger, shouldAutoCheckOnLaunch = true, buildId, }) {
        super();
        this._createdAt = Date.now();
        this._hasUpdateReadyToInstall = false;
        this._isActive = true;
        this._pendingCheckSources = [];
        this._whenInitializedResolve = () => { };
        this._autoCheckInterval = autoCheckInterval;
        this._logger = logger;
        this._shouldAutoCheckOnLaunch = shouldAutoCheckOnLaunch;
        if (buildId) {
            this.buildId = buildId;
        }
        this._whenInitialized = new Promise((resolve) => {
            this._whenInitializedResolve = resolve;
        });
        this._subscribeToElectronEvents();
    }
    /** @internal */
    _init() {
        return __awaiter(this, arguments, void 0, function* ({ getReleaseStatusFn = getReleaseStatus_1.default, } = {}) {
            const logger = this._logger;
            let inactiveReason = "";
            if (!electron.app.isPackaged) {
                inactiveReason = "application is not packaged";
            }
            if (process.platform === "linux" && !process.env.APPIMAGE) {
                inactiveReason = "application is not in AppImage";
            }
            // Maybe it's better to wait for app#ready event, but now nobody knows
            // why #will-finish-launching is used instead
            yield (0, alwaysResolve_1.default)(this._appFinishedLaunchingPromise, { logger });
            if (inactiveReason === "" && !this.buildId) {
                // Check if the current build is released before updating _unless_ we're targeting a specific build
                const { isReleased } = yield (0, alwaysResolve_1.default)(getReleaseStatusFn(logger), {
                    logger,
                    defaultResult: { isReleased: true },
                });
                if (!isReleased) {
                    inactiveReason = "the build isn't released";
                }
            }
            if (inactiveReason !== "") {
                this._isActive = false;
                const message = `@todesktop/runtime: skipping autoUpdater initialization because ${inactiveReason}.`;
                console.info(message);
                this._log("info", message);
                this._whenInitializedResolve();
                return;
            }
            this._initializeUpdaterAgent();
            if (this._autoCheckInterval > 0) {
                this._autoCheckOnInterval(this._autoCheckInterval);
            }
            if (this._shouldAutoCheckOnLaunch) {
                this._autoCheckOnLaunch().catch((e) => logger.error(e));
            }
            this._whenInitializedResolve();
        });
    }
    checkForUpdates() {
        return __awaiter(this, arguments, void 0, function* ({ source = types_1.BuiltInSources.programmaticCall, disableUpdateReadyAction = false, } = {}) {
            this._log("info", ".checkForUpdates called");
            yield (0, alwaysResolve_1.default)(this._whenInitialized);
            if (!this._isActive) {
                return {
                    updateInfo: null,
                };
            }
            return yield this._check({ source, disableUpdateReadyAction });
        });
    }
    restartAndInstall({ isSilent = false, } = {}) {
        var _a, _b;
        this._log("info", ".restartAndInstall called, isSilent: " + !!isSilent);
        if (!this._hasUpdateReadyToInstall) {
            const error = new Error("Cannot restart and install. There is no update downloaded");
            this._log("error", error);
            throw error;
        }
        this._log("debug", "Calling electron-updater's .quitAndInstall, isSilent: " + !!isSilent);
        try {
            if (isSilent) {
                /**
                 * The API name `restartAndInstall` implies that the app will be restarted.
                 * Therefore, we always restart the app and `isForceRunAfter` is always `true`.
                 */
                (_a = this._updaterAgent) === null || _a === void 0 ? void 0 : _a.restartAndInstall(true, true);
            }
            else {
                (_b = this._updaterAgent) === null || _b === void 0 ? void 0 : _b.restartAndInstall();
            }
        }
        catch (error) {
            this._log("error", "Failed to restart and install update:", error);
            this.emit("error", error);
            // Don't re-throw - let the app continue running
        }
    }
    setFeedURL(options) {
        var _a;
        (_a = this._updaterAgent) === null || _a === void 0 ? void 0 : _a.setFeedURL(options);
    }
    setBuildId(buildId) {
        this._log("info", ".setBuildId called with buildId:", buildId);
        this.buildId = buildId;
    }
    get buildId() {
        return this._buildId;
    }
    set buildId(value) {
        this._buildId = value;
        if (typeof value === "string") {
            electronUpdater.autoUpdater.channel = `latest-build-${value}`;
            this._log("debug", "Updater channel set to latest-build-" + value);
        }
        else if (value === null) {
            electronUpdater.autoUpdater.channel = "latest";
            this._log("debug", "Updater channel set to latest");
        }
    }
    _actuallyPerformCheck() {
        return __awaiter(this, arguments, void 0, function* ({ disableUpdateReadyAction, } = {}) {
            this._log("debug", "_actuallyPerformCheck called");
            if (!this._updaterAgent) {
                return { updateInfo: null };
            }
            let updateInfo;
            try {
                updateInfo = yield this._updaterAgent.checkAndDownload();
            }
            catch (error) {
                this._log("error", "Error during checkAndDownload:", error);
                this.emit("error", error);
                return { updateInfo: null };
            }
            // Reset the collected sources
            const previouslyPendingCheckSources = [
                ...this._pendingCheckSources,
            ];
            this._pendingCheckSources = [];
            // No update available; exit early
            if (!updateInfo) {
                this._log("debug", "No update available");
                // To be safe
                this._hasUpdateReadyToInstall = false;
                return {
                    updateInfo,
                };
            }
            this._log("debug", "Update available", updateInfo);
            this._hasUpdateReadyToInstall = true;
            // Emit the event
            const eventPayload = {
                sources: previouslyPendingCheckSources,
                updateInfo,
                disableUpdateReadyAction: Boolean(disableUpdateReadyAction),
            };
            this._log("debug", "Emitting update-downloaded event");
            Promise.race([
                this.emitAsync("update-downloaded", eventPayload),
                new Promise((r) => {
                    this._log("debug", "before notify call in setTimeout");
                    setTimeout(r, 500);
                }),
            ])
                .then((emitResult) => {
                if (!Array.isArray(emitResult) || !emitResult.includes(false)) {
                    this._log("debug", "calling notify after event listener Promise settled");
                    this.emit("notify-after-update-downloaded", eventPayload);
                }
            })
                .catch((e) => {
                this._log("debug", "Error occurred in update-downloaded handler", e);
                this.emit("notify-after-update-downloaded", eventPayload);
            });
            // Reset the collected sources
            this._pendingCheckSources = [];
            // Return as soon as possible (don't wait for listener responses)
            return { updateInfo };
        });
    }
    _autoCheckOnInterval(interval) {
        const checkAfterTimeout = () => {
            this._log("debug", "checking for update on interval");
            (0, setTimeout_1.default)(() => __awaiter(this, void 0, void 0, function* () {
                try {
                    yield this._check({
                        source: types_1.BuiltInSources.autoCheckOnInterval,
                        disableUpdateReadyAction: false,
                    });
                    checkAfterTimeout();
                }
                catch (e) {
                    this._log("error", e);
                    // Ignore and continute to check on interval
                    checkAfterTimeout();
                }
            }), interval);
        };
        checkAfterTimeout();
    }
    _autoCheckOnLaunch() {
        return __awaiter(this, void 0, void 0, function* () {
            this._log("debug", "checking for update on launch");
            try {
                yield this._check({
                    source: types_1.BuiltInSources.autoCheckOnLaunch,
                    disableUpdateReadyAction: false,
                });
            }
            catch (e) {
                this._log("error", e);
                // Ignore. Auto-check on interval and programmatic API still supported
            }
        });
    }
    _check(_a) {
        return __awaiter(this, arguments, void 0, function* ({ source, disableUpdateReadyAction, }) {
            /*
              We collect the sources and emit them with the update-downloaded event.
              Other noteworthy bits:
              - The update check promise is reused by electron-updater.
              - We don't want more than one event emitted.
              - There's no sorting or de-duplication of the sources, on purpose.
            */
            this._pendingCheckSources.push(source);
            this._log("debug", "_check called", {
                source,
                pendingCheckSources: this._pendingCheckSources,
            });
            if (this._pendingUpdateCheckPromise) {
                return this._pendingUpdateCheckPromise;
            }
            const onEnd = () => {
                this._pendingUpdateCheckPromise = undefined;
            };
            this._pendingUpdateCheckPromise = this._actuallyPerformCheck({
                disableUpdateReadyAction,
            })
                .then((updateCheckResult) => {
                onEnd();
                return updateCheckResult;
            })
                .catch((e) => {
                onEnd();
                throw e;
            });
            return this._pendingUpdateCheckPromise;
        });
    }
    /*
      Why are there UpdaterAgent classes?
  
      To transition apps to us, specifically Squirrel.Windows apps, we need
      to use electron-updater. They put runtime in their app, built with
      their existing tooling/infrastructure, then runtime will point to
      a Squirrel.Windows on our server which will actually use an NSIS
      installer and transition them.
  
      For Mac apps not built by us, we can use electron-updater but we need
      to make sure we point to our server.
    */
    _initializeUpdaterAgent() {
        if (process.platform === "win32" &&
            !(0, getConfig_1.default)().wasBuiltByUs &&
            // This is the official way to detect Squirrel.Windows
            fs.existsSync(path.join(electron.app.getAppPath(), "../Update.exe"))) {
            this._log("debug", "Setting up SquirrelWindowsUpdaterAgent");
            this._updaterAgent = new updaterAgents_1.SquirrelWindowsUpdaterAgent({
                log: (level, ...args) => {
                    this._log(level, "SquirrelWindowsUpdaterAgent:", ...args);
                },
                logger: this._logger,
            });
            return;
        }
        this._log("debug", "Setting up UpdaterAgent");
        this._updaterAgent = new updaterAgents_1.UpdaterAgent({
            log: (level, ...args) => {
                this._log(level, "UpdaterAgent:", ...args);
            },
            logger: this._logger,
        });
    }
    _log(level, ...args) {
        let firstArgument;
        if (process.env.AVA_PATH) {
            let timeSinceCreatedAt;
            // This can fail when there's a ReferenceError in a test and Date is overwritten
            try {
                timeSinceCreatedAt = ` (${Date.now() - this._createdAt}ms)`;
            }
            catch (e) {
                timeSinceCreatedAt = "";
            }
            firstArgument = `AutoUpdater (${electron.app.name})${timeSinceCreatedAt}:`;
        }
        else {
            firstArgument = "AutoUpdater:";
        }
        this._logger[level](firstArgument, ...args);
    }
    _subscribeToElectronEvents() {
        this._appFinishedLaunchingPromise = new Promise((resolve) => {
            electron.app.on("will-finish-launching", () => {
                this._log("debug", "electron will-finish-launching event emitted", {
                    appVersion: electron.app.getVersion(),
                    runtimeVersion: version_1.CLIENT_VERSION,
                });
                resolve();
            });
        });
        electron.autoUpdater.on("before-quit-for-update", (...args) => {
            this._log("info", "before-quit-for-update");
            this.emit("before-quit-for-update", ...args);
        });
        electronUpdater.autoUpdater.on("error", (error, message) => {
            this._log("info", "error");
            this.emit("error", error, message);
        });
        electronUpdater.autoUpdater.on("checking-for-update", () => {
            this._log("info", "checking-for-update");
            this.emit("checking-for-update");
        });
        electronUpdater.autoUpdater.on("update-not-available", (info) => {
            this._log("info", "update-not-available", info);
            this.emit("update-not-available", info);
        });
        electronUpdater.autoUpdater.on("update-available", (info) => {
            this._log("info", "update-available", info);
            this.emit("update-available", info);
        });
        // we emit update-downloaded ourselves in `_actuallyPerformCheck`
        electronUpdater.autoUpdater.on("download-progress", (info) => {
            this._log("info", "download-progress", info);
            this.emit("download-progress", info);
        });
    }
}
exports.default = AutoUpdater;
