"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const AutoUpdater_1 = require("./autoUpdater/AutoUpdater");
const cache_1 = require("./cache");
const Logger_1 = require("./Logger");
const MockedAutoUpdater_1 = require("./autoUpdater/MockedAutoUpdater");
const Notifier_1 = require("./Notifier");
const SimulatedAutoUpdater_1 = require("./autoUpdater/SimulatedAutoUpdater");
const msi_1 = require("./targets/msi");
class ToDesktop {
    constructor() {
        this.isSmokeTestMode = Boolean(process.env.TODESKTOP_SMOKE_TEST);
    }
    // This initializes everything. It must be called (at the top of their main script)
    init(params = {}) {
        if (this.isSmokeTestMode) {
            this.autoUpdater = (0, MockedAutoUpdater_1.createMockedAutoUpdater)();
        }
        else {
            this.autoUpdater = this._init(params);
        }
    }
    /** @internal */
    _init(_a = {}) {
        var { autoCheckInterval, autoUpdater = true, customLogger, shouldAutoCheckOnLaunch, updateReadyAction, buildId } = _a, initAutoUpdaterOptions = __rest(_a, ["autoCheckInterval", "autoUpdater", "customLogger", "shouldAutoCheckOnLaunch", "updateReadyAction", "buildId"]);
        const logger = new Logger_1.default(customLogger);
        const Updater = (0, SimulatedAutoUpdater_1.parseSimulateUpdatesFlag)()
            ? SimulatedAutoUpdater_1.SimulatedAutoUpdater
            : AutoUpdater_1.default;
        let autoUpdaterInstance;
        if (autoUpdater) {
            autoUpdaterInstance = new Updater({
                logger,
                autoCheckInterval,
                shouldAutoCheckOnLaunch,
                buildId,
            });
            new Notifier_1.default({ autoUpdater: autoUpdaterInstance, updateReadyAction });
        }
        else {
            // Disables the default behaviour
            autoUpdaterInstance = new Updater({
                autoCheckInterval: 0,
                logger,
                shouldAutoCheckOnLaunch: false,
            });
        }
        autoUpdaterInstance
            ._init(initAutoUpdaterOptions)
            .catch((e) => logger.error(e));
        return autoUpdaterInstance;
    }
    get runtime() {
        return {
            isInstalledUsingWindowsMSI: () => (0, msi_1.isInstalledUsingMSI)(),
        };
    }
}
let todesktop;
if (cache_1.default.get()) {
    todesktop = cache_1.default.get();
}
else {
    todesktop = new ToDesktop();
    cache_1.default.set(todesktop);
}
if (todesktop.isSmokeTestMode) {
    Promise.resolve().then(() => require("./initSmokeTest")).then(({ default: initSmokeTest }) => initSmokeTest(todesktop))
        .catch(() => {
        // Ignore
    });
}
module.exports = todesktop;
